<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tech grumbling</title><link>https://cardinalby.github.io/blog/</link><description>Recent content on Tech grumbling</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>cardinalby</copyright><lastBuildDate>Sun, 08 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://cardinalby.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Storing currency values: data types, caveats, best practices</title><link>https://cardinalby.github.io/blog/post/best-practices/storing-currency-values-data-types/</link><pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/best-practices/storing-currency-values-data-types/</guid><description>Intro Repeatedly facing questions, debates, and mistakes related to storing and representing currency amounts, I decided to collect all facts and advice regarding this topic in one place. This article is not the final source of the truth, but it contains useful information that you should take into consideration when designing software.
Domain info: currencies Just facts: There is ISO 4217 standard that describes currency codes and their minor units. Data are also available in XML and CSV representations (following the links from the page).</description></item><item><title>About</title><link>https://cardinalby.github.io/blog/page/about/</link><pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/page/about/</guid><description>About It&amp;rsquo;s a tech blog of a grumbling software engineer.</description></item><item><title>JavaScript GitHub Action packing and releasing</title><link>https://cardinalby.github.io/blog/post/github-actions/js-action-packing-and-releasing/</link><pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/js-action-packing-and-releasing/</guid><description>üî≠ Overview In this article I want to share some undocumented details of creating JavaScript GitHub Actions related to the using of ncc packing tool.
It&amp;rsquo;s not just a step-by-step instruction, but the story describing the problem, the proposed approach and the reasoning behind it.
If you are just looking for a quick code example, jump to this one and come back for an explanation üôÇ
üé¨ Basics that you already know The basic approach is pretty easy and described in GitHub documentation here.</description></item><item><title>The main workflow</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/9-the-main-workflow/</link><pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/9-the-main-workflow/</guid><description>We have prepared all the needed composite actions and workflows, and we are finally ready to create the main workflow that triggers the entire pipeline.
.github/workflows/publish-release-on-tag.yml :
name: Release and publish on tag on: push: tags: - &amp;#39;*.*.*&amp;#39; workflow_dispatch: jobs: build-release-publish: if: github.ref_type == &amp;#39;tag&amp;#39; runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: cardinalby/export-env-action@v1 with: envFile: &amp;#39;./.github/workflows/constants.env&amp;#39; expand: true - name: Look for an existing release id: getRelease uses: cardinalby/git-get-release-action@v1 continue-on-error: true with: tag: ${{ github.</description></item><item><title>Don't let Google refresh token expire</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/8-google-api-refresh-token-expiration/</link><pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/8-google-api-refresh-token-expiration/</guid><description>In this part we will finish setting up workflows related to publishing the extension on Google Web Store and create the workflow that isn&amp;rsquo;t shown on the workflow diagram because it stays aside and isn&amp;rsquo;t included to the main pipeline.
Dealing with Google API credentials we should be aware of the fact that, according to Google&amp;rsquo;s guide, refresh token (which we use in the workflow from the previous part) might stop working if it has not been used for six months.</description></item><item><title>Publish on Chrome Web Store</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/7-publish-on-chrome-web-store/</link><pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/7-publish-on-chrome-web-store/</guid><description>In this part we are going to create the workflow that will be responsible for publishing the extension on Chrome Web Store. This part is going to be a bit tricky comparing to the others.
üß± Prepare ‚ù∂ To set up Google Publish API access you need to obtain clientId, clientSecret and refreshToken from Google. These articles can help you to do that: * Using the Chrome Web Store Publish API * How to generate Google API keys</description></item><item><title>Publish on Firefox Add-ons</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/6-publish-on-firefox-addons/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/6-publish-on-firefox-addons/</guid><description>In this part we are going to create the workflow that will be responsible for publishing the extension on Firefox Add-ons marketplace.
üß± Prepare First, you need to find out your extension UUID. You can find it on your extension&amp;rsquo;s page at Add-on Developer Hub in the &amp;ldquo;Technical Details&amp;rdquo; section.
Next, follow the official documentation and obtain jwtIssuer and jwtSecret values required for accessing the API.
üîí Add these values to secrets: FF_EXTENSION_ID - UUID of your extension (e.</description></item><item><title>Publish on Edge Add-ons</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/5-publish-on-edge-addons/</link><pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/5-publish-on-edge-addons/</guid><description>In this part we are going to create the workflow for publishing the extension on Microsoft Edge Add-ons. The reason why we are starting from the least popular store is that the process is going to be the easiest one among other stores.
üß± Prepare First, you need to find the Product ID of your extension. You can find it in Developer Dashboard. Be attentive, there are also 2 other identifiers that we don&amp;rsquo;t need - Store ID and CRX ID.</description></item><item><title>Build release assets</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/4-build-release-assets/</link><pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/4-build-release-assets/</guid><description>build-assets-on-release workflow Let&amp;rsquo;s create the first workflow that utilizes build-test-pack action and builds release assets for offline distribution once a release has been published.
.github/workflows/build-assets-on-release.yml:
name: Build release assets on: release: # Creating draft releases will not trigger it types: [published] jobs: # We will add 3 jobs here... The workflow will have 3 jobs:
ensure-zip: Ensuring we have zip release asset. build-signed-crx-asset: Building crx asset. build-signed-xpi-asset: Building xpi asset. ensure-zip job The first job will find zip asset in the release or build it if not found:</description></item><item><title>Composite actions</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/3-composite-actions/</link><pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/3-composite-actions/</guid><description>In this part we will start with implementing composite actions, the base building blocks that are used in the workflows.
We save all created actions locally in the repo in .github/workflows/actions directory. Every action has own named directory and a single action.yml file in it.
build-test-pack action .github/workflows/actions/build-test-pack/action.yml :
name: &amp;#34;Build, test and pack WebExtension&amp;#34; description: &amp;#34;Builds, tests, and packs extension dir into zip file&amp;#34; inputs: doNotPackZip: description: &amp;#39;Set `true` to omit pack step&amp;#39; required: false runs: using: &amp;#34;composite&amp;#34; steps: # Add additional build and test steps here - name: Validate manifest.</description></item><item><title>Workflows diagram</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/2-workflows-diagram/</link><pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/2-workflows-diagram/</guid><description>High level overview In this part we will observe the high level architecture of the solution: the proposed workflows and the order in that they are called. We will also find duplicated steps and extract them to the composite actions.
Workflows and events Let&amp;rsquo;s take a look at the vertical Ghant diagram of the pipeline triggered by pushing a tag.
The main publish-release-on-tag workflow is triggered when a user pushes a tag.</description></item><item><title>Introduction. Constants</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/1-introduction/</link><pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/1-introduction/</guid><description>Introduction In this article, I&amp;rsquo;m going to share my approach of preparing a complete CI/CD solution for building and publishing a browser extension (WebExtension) based on GitHub Actions:
Reusable building and testing pipeline. Releasing and building artifacts for offline distribution. Publishing an extension on Chrome Web Store, Firefox Add-ons and Edge Add-ons stores. The described workflows are based on the existing and tested workflows for my &amp;ldquo;Memrise Audio Uploader&amp;rdquo; extension.</description></item><item><title>GitHub Actions integration testing lib</title><link>https://cardinalby.github.io/blog/project/github-actions-testing-lib/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/project/github-actions-testing-lib/</guid><description>Check out https://github.com/cardinalby/github-action-ts-run-api
Purpose üî∂ Executing your GitHub action locally (or at any other environment).
üî∂ Writing integration and functional tests, run them locally and at CI.
üî∂ Having a short feedback loop without pushing and checking it behaviour at real GitHub runners every time.
Features ‚úÖ Supports executing JavaScript and Docker actions.
‚úÖ Tested under Windows, Linux and macOS locally and on GitHub hosted runners.
‚úÖ Works well with Docker Desktop under Windows and macOS (for Docker actions).</description></item><item><title>DRY: reusing code in GitHub Actions</title><link>https://cardinalby.github.io/blog/post/github-actions/dry-reusing-code-in-github-actions/</link><pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/dry-reusing-code-in-github-actions/</guid><description>In this post I want to make a quick overview of the approaches of reusing steps of your workflow to avoid duplication of the same steps across different workflows or jobs.
üî∏ Reusing workflows The obvious option is using the &amp;ldquo;Reusable workflows&amp;rdquo; feature that allows you to extract some steps into a separate &amp;ldquo;reusable&amp;rdquo; workflow and call this workflow as a job in other workflows.
ü•° Takeaways: Nested reusable workflow calls are allowed (up to 4 levels) while loops are not permitted.</description></item><item><title>System testing of GitHub Actions</title><link>https://cardinalby.github.io/blog/post/github-actions/testing/4-system-testing-of-github-actions/</link><pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/testing/4-system-testing-of-github-actions/</guid><description>It&amp;rsquo;s the last and the shortest part of the series. Testing the whole action as a black box can be done in 2 ways (as far as I can see).
github-action-ts-run-api again Use the same tool as for integration test, but run tests against the whole action.
Use Act tool This approach implies that you should create special testing workflows that can be naturally run on GitHub Actions runner or can be run locally using Act.</description></item><item><title>Testing of Docker Actions</title><link>https://cardinalby.github.io/blog/post/github-actions/testing/3-testing-of-docker-actions/</link><pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/testing/3-testing-of-docker-actions/</guid><description>In this part I&amp;rsquo;m going to tell about approaches that can be used to test a Docker container Action.
Unit tests An approach here depends on what programming language you use inside a container. Each of them has own testing libraries that can be used to test an application in the container.
If you use bare bash script, you can divide a single entrypoint.sh file into the several small scripts considering them as units and testing separately.</description></item><item><title>Testing of JavaScript Actions</title><link>https://cardinalby.github.io/blog/post/github-actions/testing/2-testing-of-js-actions/</link><pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/testing/2-testing-of-js-actions/</guid><description>Let&amp;rsquo;s talk about JavaScript GitHub Actions and approaches that we can apply on the different levels of testing.
Unit tests From my point of view, unit testing of Actions doesn&amp;rsquo;t have any differences from testing any other JavaScript code. In most of the examples of Actions available on the GitHub Marketplace authors don&amp;rsquo;t care about writing testable code. But nothing prevents you from extracting abstractions and following The Dependency Inversion Principle which will allow you to easily mock dependencies (such as @actions/core , @actions/github, @actions/exec packages).</description></item><item><title>Testing of GitHub Actions. Intro</title><link>https://cardinalby.github.io/blog/post/github-actions/testing/1-testing-of-github-actions-intro/</link><pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/testing/1-testing-of-github-actions-intro/</guid><description>Introduction In this post series I want to share my experience and approaches with testing of GitHub Actions. Not using them to test your application, but test actions itself. I will mostly talk about testing of individual actions, not workflows.
Individual actions (steps) are &amp;ldquo;bricks&amp;rdquo; that workflows are built from, and we can consider testing them as unit testing of workflows.
One of the problems of GitHub Actions as cloud-based service is that there is no out of the box way of test them locally.</description></item><item><title>GitHub Actions: implementing deferred steps</title><link>https://cardinalby.github.io/blog/post/github-actions/implementing-deferred-steps/</link><pubDate>Mon, 01 Nov 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/implementing-deferred-steps/</guid><description>‚ö°Ô∏è GitHub Actions can do everything&amp;hellip; but immediately Sometimes you can‚Äôt finish your CI/CD job in a single run: you have to wait for some event or until an external long-running process finishes. To do that, we need a possibility to delay/postpone/defer some steps and repeat them (probably multiple times until they succeed).
For example, I faced the issue with WebExtension publishing. After calling the Web Store API I have to wait up to week or two until my extension gets reviewed and only then I will be able to download published and packed file and add it to a GitHub release.</description></item><item><title>"Tea collage" creative project</title><link>https://cardinalby.github.io/blog/project/google-maps-extended-routes/</link><pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/project/google-maps-extended-routes/</guid><description>The great web extension for motorbikers, cyclists and everyone who use Google Maps for planning long routes.
üö¥ Extend routes beyond 10 points
üìè Optimize multi-stop routes for shorter travel to save time and fuel
üì± Prepare a route for mobile navigation solving &amp;ldquo;disappearing waypoints&amp;rdquo; problem
üåç Export your route to popular services: Apple Maps, TomTom Planner, Bing Maps and Yandex Maps
üíæ Download a route as GPX or KML file</description></item><item><title>"Tea collage" creative project</title><link>https://cardinalby.github.io/blog/project/tea-collage/</link><pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/project/tea-collage/</guid><description>The project is a digital interactive addition to a collage of Chinese tea wrappers that I have been drinking for the past three years.
I have always loved teas and drank them in exorbitant quantities, but I went deeper into the topic of Chinese teas since 2015.
Open Tea Collage One of the my favorite tea sort is shu and shen pu-erh; traditionally they are made in the form of pressed cakes.</description></item><item><title>Memrise Audio Uploader</title><link>https://cardinalby.github.io/blog/project/memrise-audio-uploader/</link><pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/project/memrise-audio-uploader/</guid><description>Memrise Audio Uploader is a Chrome extension which allows you to upload sounds of words and phrases pronunciation from soundoftext.com to memrise.com course.
Check out the source code https://github.com/cardinalby/memrise-audio-uploader
Install from the stores Chrome Web Store
Firefox Add-ons
To download the offline versions please go to the Releases page.
Screenshots</description></item></channel></rss>