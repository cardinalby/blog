<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>github-actions on Tech grumbling</title><link>https://cardinalby.github.io/blog/tags/github-actions/</link><description>Recent content in github-actions on Tech grumbling</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>cardinalby</copyright><lastBuildDate>Thu, 17 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://cardinalby.github.io/blog/tags/github-actions/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript GitHub Action packing and releasing</title><link>https://cardinalby.github.io/blog/post/github-actions/js-action-packing-and-releasing/</link><pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/js-action-packing-and-releasing/</guid><description>üî≠ Overview In this article I want to share some undocumented details of creating JavaScript GitHub Actions related to the using of ncc packing tool.
It&amp;rsquo;s not just a step-by-step instruction, but the story describing the problem, the proposed approach and the reasoning behind it.
If you are just looking for a quick code example, jump to this one and come back for an explanation üôÇ
üé¨ Basics that you already know The basic approach is pretty easy and described in GitHub documentation here.</description></item><item><title>The main workflow</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/8-the-main-workflow/</link><pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/8-the-main-workflow/</guid><description>We have prepared all the needed composite actions and workflows, and we are finally ready to create the main workflow that triggers the entire pipeline.
.github/workflows/publish-release-on-tag.yml :
name:Release and publish on tagon:push:tags:- &amp;#39;*.*.*&amp;#39;workflow_dispatch:jobs:build-release-publish:if:github.ref_type == &amp;#39;tag&amp;#39;runs-on:ubuntu-lateststeps:- uses:actions/checkout@v2- uses:cardinalby/export-env-action@v1with:envFile:&amp;#39;./.github/workflows/constants.env&amp;#39;expand:true- name:Look for an existing releaseid:getReleaseuses:cardinalby/git-get-release-action@v1continue-on-error:truewith:tag:${{ github.ref_name }}env:GITHUB_TOKEN:${{ github.token }}- name:Build, test and pack to zipid:buildPackif:steps.getRelease.outcome != &amp;#39;success&amp;#39;uses:./.github/workflows/actions/build-test-pack- name:Create Releaseid:createReleaseif:steps.getRelease.outcome != &amp;#39;success&amp;#39;uses:ncipollo/release-action@v1with:token:${{ secrets.GITHUB_TOKEN }}draft:&amp;#39;true&amp;#39;- name:Upload zip asset to the releaseif:steps.getRelease.outcome != &amp;#39;success&amp;#39;uses:actions/upload-release-asset@v1env:GITHUB_TOKEN:${{ secrets.GITHUB_TOKEN }}with:upload_url:${{ steps.</description></item><item><title>Don't let Google refresh token expire</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/7-google-api-refresh-token-expiration/</link><pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/7-google-api-refresh-token-expiration/</guid><description>In this part we will finish setting up workflows related to publishing the extension on Google Web Store and create the workflow that isn&amp;rsquo;t shown on the workflow diagram because it stays aside and isn&amp;rsquo;t included to the main pipeline.
Dealing with Google API credentials we should be aware of the fact that, according to Google&amp;rsquo;s guide, refresh token (which we use in the workflow from the previous part) might stop working if it has not been used for six months.</description></item><item><title>Publish on Chrome Web Store</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/6-publish-on-chrome-web-store/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/6-publish-on-chrome-web-store/</guid><description>In this part we are going to create the workflow that will be responsible for publishing the extension on Chrome Web Store. This part is going to be a bit tricky comparing to the others.
üß± Prepare ‚ù∂ To set up Google Publish API access you need to obtain clientId, clientSecret and refreshToken from Google. These articles can help you to do that: * Using the Chrome Web Store Publish API * How to generate Google API keys</description></item><item><title>Publish on Firefox Add-ons</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/5-publish-on-firefox-addons/</link><pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/5-publish-on-firefox-addons/</guid><description>In this part we are going to create the workflow that will be responsible for publishing the extension on Firefox Add-ons marketplace.
üß± Prepare First, you need to find out your extension UUID. You can find it on your extension&amp;rsquo;s page at Add-on Developer Hub in the &amp;ldquo;Technical Details&amp;rdquo; section.
Next, follow the official documentation and obtain jwtIssuer and jwtSecret values required for accessing the API.
üîí Add these values to secrets: FF_EXTENSION_ID - UUID of your extension FF_JWT_ISSUER FF_JWT_SECRET publish-on-firefox-add-ons workflow The workflow will have the only trigger: workflow_dispatch event.</description></item><item><title>Build release assets</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/4-build-release-assets/</link><pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/4-build-release-assets/</guid><description>build-assets-on-release workflow Let&amp;rsquo;s create the first workflow that utilizes build-test-pack action and builds release assets for offline distribution once a release has been published.
.github/workflows/build-assets-on-release.yml:
name:Build release assetson:release:# Creating draft releases will not trigger ittypes:[published]jobs:# We will add 3 jobs here...The workflow will have 3 jobs:
ensure-zip: Ensuring we have zip release asset. build-signed-crx-asset: Building crx asset. build-signed-xpi-asset: Building xpi asset. ensure-zip job The first job will find zip asset in the release or build it if not found:</description></item><item><title>Composite actions</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/3-composite-actions/</link><pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/3-composite-actions/</guid><description>In this part we will start with implementing composite actions, the base building blocks that are used in the workflows.
We save all created actions locally in the repo in .github/workflows/actions directory. Every action has own named directory and a single action.yml file in it.
build-test-pack action .github/workflows/actions/build-test-pack/action.yml :
name:&amp;#34;Build, test and pack WebExtension&amp;#34;description:&amp;#34;Builds, tests, and packs extension dir into zip file&amp;#34;inputs:doNotPackZip:description:&amp;#39;Set `true` to omit pack step&amp;#39;required:falseruns:using:&amp;#34;composite&amp;#34;steps:# Add additional build and test steps here- name:Validate manifest.</description></item><item><title>Workflows diagram</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/2-workflows-diagram/</link><pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/2-workflows-diagram/</guid><description>High level overview In this part we will observe the high level architecture of the solution: the proposed workflows and the order in that they are called. We will also find duplicated steps and extract them to the composite actions.
Workflows and events Let&amp;rsquo;s take a look at the vertical Ghant diagram of the pipeline triggered by pushing a tag.
The main publish-release-on-tag workflow is triggered when a user pushes a tag.</description></item><item><title>Introduction. Constants</title><link>https://cardinalby.github.io/blog/post/github-actions/webext/1-introduction/</link><pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/webext/1-introduction/</guid><description>Introduction In this article, I&amp;rsquo;m going to share my approach of preparing a complete CI/CD solution for building and publishing a browser extension ( WebExtension) based on GitHub Actions:
Reusable building and testing pipeline. Releasing and building artifacts for offline distribution. Publishing an extension on Chrome Web Store and Firefox Add-ons store. The described workflows are based on the existing and tested workflows for my &amp;ldquo;Memrise Audio Uploader&amp;rdquo; extension.</description></item><item><title>DRY: reusing code in GitHub Actions</title><link>https://cardinalby.github.io/blog/post/github-actions/dry-reusing-code-in-github-actions/</link><pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/dry-reusing-code-in-github-actions/</guid><description>In this post I want to make a quick overview of the approaches of reusing steps of your workflow to avoid duplication of the same steps across different workflows or jobs.
üî∏ Reusing workflows The obvious option is using the &amp;ldquo;Reusable workflows&amp;rdquo; feature that allows you to call extract some steps into a separate &amp;ldquo;reusable&amp;rdquo; workflow and call this workflow as a job in other workflows.
ü•° Takeaways: Reusable workflows can&amp;rsquo;t call other reusable workflows.</description></item><item><title>System testing of GitHub Actions</title><link>https://cardinalby.github.io/blog/post/github-actions/testing/4-system-testing-of-github-actions/</link><pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/testing/4-system-testing-of-github-actions/</guid><description>It&amp;rsquo;s the last and the shortest part of the series. Testing the whole action as a black box can be done in 2 ways (as far as I can see).
github-action-ts-run-api again Use the same tool as for integration test, but run tests against the whole action.
Use Act tool This approach implies that you should create special testing workflows that can be naturally run on GitHub Actions runner or can be run locally using Act.</description></item><item><title>Testing of Docker Actions</title><link>https://cardinalby.github.io/blog/post/github-actions/testing/3-testing-of-docker-actions/</link><pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/testing/3-testing-of-docker-actions/</guid><description>In this part I&amp;rsquo;m going to tell about approaches that can be used to test a Docker container Action.
Unit tests An approach here depends on what programming language you use inside a container. Each of them has own testing libraries that can be used to test an application in the container.
If you use bare bash script, you can divide a single entrypoint.sh file into the several small scripts considering them as units and testing separately.</description></item><item><title>Testing of JavaScript Actions</title><link>https://cardinalby.github.io/blog/post/github-actions/testing/2-testing-of-js-actions/</link><pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/testing/2-testing-of-js-actions/</guid><description>Let&amp;rsquo;s talk about JavaScript GitHub Actions and approaches that we can apply on the different levels of testing.
Unit tests From my point of view, unit testing of Actions doesn&amp;rsquo;t have any differences from testing any other JavaScript code. In most of the examples of Actions available on the GitHub Marketplace authors don&amp;rsquo;t care about writing testable code. But nothing prevents you from extracting abstractions and following The Dependency Inversion Principle which will allow you to easily mock dependencies (such as @actions/core , @actions/github, @actions/exec packages).</description></item><item><title>Testing of GitHub Actions. Intro</title><link>https://cardinalby.github.io/blog/post/github-actions/testing/1-testing-of-github-actions-intro/</link><pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/testing/1-testing-of-github-actions-intro/</guid><description>Introduction In this post series I want to share my experience and approaches with testing of GitHub Actions. Not using them to test your application, but test actions itself. I will mostly talk about testing of individual actions, not workflows.
Individual actions (steps) are &amp;ldquo;bricks&amp;rdquo; that workflows are built from, and we can consider testing them as unit testing of workflows.
One of the problems of GitHub Actions as cloud-based service is that there is no out of the box way of test them locally.</description></item><item><title>GitHub Actions: implementing deferred steps</title><link>https://cardinalby.github.io/blog/post/github-actions/implementing-deferred-steps/</link><pubDate>Mon, 01 Nov 2021 00:00:00 +0000</pubDate><guid>https://cardinalby.github.io/blog/post/github-actions/implementing-deferred-steps/</guid><description>‚ö°Ô∏è GitHub Actions can do everything&amp;hellip; but immediately Sometimes you can‚Äôt finish your CI/CD job in a single run: you have to wait for some event or until an external long-running process finishes. To do that, we need a possibility to delay/postpone/defer some steps and repeat them (probably multiple times until they succeed).
For example, I faced the issue with WebExtension publishing. After calling the Web Store API I have to wait up to week or two until my extension gets reviewed and only then I will be able to download published and packed file and add it to a GitHub release.</description></item></channel></rss>